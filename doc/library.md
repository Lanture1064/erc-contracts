# Library

[Library](https://github.com/bestchains/bestchains-contracts/tree/main/library) provies utilities for [Contracts](https://github.com/bestchains/bestchains-contracts/tree/main/contracts),including:

- Address
- Message
- Context
- Counter

etc...

## Address

`Address` here we defined as a 42 length hex string which follows [Ethereum Externally-owned account (EOA)](https://ethereum.org/en/developers/docs/accounts/#externally-owned-accounts-and-key-pairs) which follows [rules](https://ethereum.org/en/developers/docs/accounts/#contract-accounts)

- 42 length hex string
- prefixed by `0x`
- `0x0000000000000000000000000000000000000000` treated as `ZeroAddress`
- Only `ECDSA Public Key` supported

Calculation logic from a public key

```go
func (addr *Address) FromPublicKey(pub interface{}) error {
	publicKey, ok := pub.(*ecdsa.PublicKey)
	if !ok {
		return ErrUnknownAddressAlg
	}
	// Serialize the public key
	serializedPubKey := elliptic.Marshal(elliptic.P256(), publicKey.X, publicKey.Y)

	// Hash the public key using Keccak-256
	hashedPubKey := sha3.Sum256(serializedPubKey)

	// Truncate the hash and add a prefix to get the final Ethereum address
	addr.FromString(AddressPrefix + hex.EncodeToString(hashedPubKey[12:]))

	return nil
}
```

## Message

To make chaincode more decentralized, we use `Message` for **second-class** blockchain account which simulates etheruem transaction's `msg.sender`

```
type Message struct {
	Nonce     uint64 `json:"nonce"`
	PublicKey []byte `json:"publicKey"`
	Signature []byte `json:"signature"`
}
```

- `Nonce` is just like `ethereum transaction's nonce` which is a sequentially incrementing counter which indicates the transaction number from the `msg.sender`.

> To enable this in your chaincode, you can use [NonceContract](../contracts/nonce/interfaces.go)

- `PublicKey` is the marshaled `ECDSA Public Key`

- `Signature` is generated by `PublicKey`'s relevant `PrivateKey`

In [Message](../library/context/message.go), we provide functions to generate/verify signatures agains tx's input arguments

```go
func (msg *Message)GenerateSignature(privkey *ecdsa.PrivateKey, args ...string) error
func (msg *Message)VerifyAgainstArgs(args ...string) (library.Address, error)
```

## Context

[Context](https://github.com/bestchains/bestchains-contracts/blob/main/library/context/context.go) inherits from [TransactionContextInterface](https://github.com/hyperledger/fabric-contract-api-go/blob/main/contractapi/transaction_context.go#L15) by following [doc](https://github.com/hyperledger/fabric-contract-api-go/blob/main/tutorials/using-advanced-features.md#transaction-hooks).

To be explicitly,we implements following interfaces

```go
type ContextInterface interface {
	contractapi.TransactionContextInterface

	Operator() library.Address

	SetMsgSender(library.Address)
	MsgSender() library.Address

	EmitEvent(event string, payload interface{}) error
}
```

1. `Operator() library.Address`
Used to extract the transaction's creator which is a authorized user from a network member.
2. `SetMsgSender(library.Address) library.Address`
Used to set current transaction's `second-class` sender.
3. `MsgSender() library.Address`
Used to get current transactions' `second-class` sender.
4. `EmitEvent(event string,payload interface{})`
Wraps chaincode's event trigger logic.

### How we get the message sender(second-class sender)?

1. A function must put `Message` as its 1st argument

```go
func (erc1155 *ERC1155) SetApprovalForAll(ctx context.ContextInterface, msg context.Message, operator string, approved bool) error
```

2. The `second-class` user calls this `function`,it assembles a `Message` with `message.GenerateSignature`

3. Our context then extracts `second-class` user from message by `context.go BeforeTransaction`

## Counter

`Counter` provies very basic functions

```go
Current() uint64 
Increment()
Decrement() 
Reset()
```

